---
title: Módulo Sqlite3
author: enidev911
categories: [Python, Módulos]
mermaid: true
pin: true
tags: [módulos]
image:
    path: /assets/img/posters/python-sqlite3.png
    alt: "DB-API 2.0 es un estándar definido por Python"
---

Python DB-API es un conjunto de estándares recomendados por un grupo de interés especial para la estandarización de módulos de base de datos. Los estándares DB-API se modificaron aún más en DB-API 2.0 mediante otra propuesta de mejora que se específica en el [PEP-249](https://peps.python.org/pep-0249/){: target='_blank' }

Según los estándares prescritos, el primer paso del proceso es obtener la conexión con el objeto que representa la base de datos.

## Conexión a una Base De Datos

Para establecer una conexión con la base de datos SQLite, es necesario importar el módulo sqlite3 y ejecutar el método `connect()`:

```python
import sqlite3

db_connection = sqlite3.connect("university.db")
```
{: .nolineno }


### Métodos de un objeto Conexión

El método `connect()` devuelve un objeto de conexión que hace referencia a la base de datos existente o una nueva base de datos si no existe.

Los siguientes métodos del objeto conexión son útiles:

|Método|Descripción|
|:-----|:----------|
|`cursor()`|Devuelve un objeto cursor que usa esta conexión.|
|`commit()`|Compromete explícitamente cualquier transacción pendiente a la base de datos.|
|`rollback()`|Este método opcional hace que una transacción se retrotraiga al punto de partida.|
|`close()`|Cierra la conexión a la base de datos de forma permanente.|

Los métodos `commit()` y `rollback()` del objeto de conexión garantizan el control de transacciones. Ejemplo:

```python
import sqlite3

db = sqlite3.connect("university.db")
try:
  db.execute("Query")
  db.commit()
else:
  print("Error")
  db.rollback()
db.close()
```
{: .nolineno }


## Crear un Cursor

Un cursor es un objeto de Python que le permite trabajar con la base de datos, actúa como un identificador para una consulta SQL determinada; permite la recuperación de una o más filas del resultado. Para crear un cursor utilizamos el objeto de conexión de la siguiente forma:

```python
import sqlite3

db_connection = sqlite3.connect('university.db')
cursor = db_connection.cursor()
```
{: .nolineno }


### Métodos de un objeto Cursor

Los siguientes métodos del objeto cursor son útiles:

|Método|Descripción|
|:-----|:----------|
|`execute()`|Ejecuta la consulta SQL como parámetro de cadena.|
|`executemany()`|Ejecuta la consulta SQL usando un conjunto de parámetros en la lista de tuplas.|
|`fetchone`|Obtiene la siguiente fila del conjunto de resultado de la consulta.|
|`fetchall()`|Obtiene todas las filas restante del conjunto de resultados de la consulta.|
|`close()`|Cierra el objeto cursor.|

#### Crear una tabla

Una cadena que encierra la consulta `CREATE TABLE` se pasa como parámetros al método `execute()` del objeto cursor. El siguiente código crea las tabla students en la base de datos **university.db**:

```python
import sqlite3
db = sqlite3.connect('university.db')
try:
  cur = db.cursor()
  cur.execute('''
    CREATE TABLE students(
      ID INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT(30) NOT NULL,
      age INTEGER,
      note REAL);
  ''')
  print('Table created successfully')
except:
  print('Error in operation')
  db.rollback()
db.close() 
```

### Insertar un registro

Ya que tenemos una tabla, podemos usar nuevamente el método `execute()` del objeto cursor con un argumento de cadena que represente la consulta `INSERT` . Ejemplo:

```python
qry = "INSERT INTO students (name, age, note) VALUES ('john', 33, 6.5);"
```
{: .nolineno }

Ahora la cadena anterior, debemos usarla como parámetro del método `execute`:

```python
cursor.execute(qry)
```
{: .nolineno }


### CRUD


Ahora vamos hacer un CRUD completo, para que tengamos una aplicación de consola. ¿Entretenido? 😎🤭

Para facilitarnos la existencia, vamos a modularizar el código, comenzando por tener en un archivo `db.py` lo relacionado con la creación y configuración de la base de datos:

```python
import sqlite3
from sqlite3 import Error
import os

CURDIR = os.path.dirname(os.path.abspath(__file__))
FILENAME = "schema.sql"
FILE = os.path.join(CURDIR, "db", FILENAME)

def open_db():
    try:
        con = sqlite3.connect('cars.db')
        return con
    except Error as e:
        print('Error: ', e)

def run_query(sql, params='', multiple=False):

    with open_db() as con:
        cursor = con.cursor()
        try:
            if multiple:
                return cursor.executemany(sql, params)
            else:
                return cursor.execute(sql, params)
        except Error as e:
            print('Error: ', e)

def create_schema():
    with open(FILE, 'r') as sql_file:
        sql_script = sql_file.read()
        schema_created = run_query(sql_script)
        if schema_created.rowcount == -1:
            print("Database created successfully")

if __name__ == "__main__":
    create_schema()
```
{: file="db.py" }


Vamos a resumir que hace el código anterior, sobretodo las funciones:

**`open_db`**
: Se encargará de crear o abrir la base de datos y se maneja a través `try/except` para capturar posibles errores.

**`run_query`**
: Esta función va a utilizar la conexión que retorna `open_db` y con ella podemos realizar consultas a la base de datos.

**`create_schema()`**
: Esta función va a construir el esquema de la base de datos que tenemos definido en un archivo llamado `schema.sql`.


#### Insertar Datos

Para comenzar con las operaciones del CRUD, en un archivo `crud.py` definiremos las funciones de las 4 operaciones:

```python
import db

def insert_data():
  insert_query = "INSERT INTO cars (brand, model) VALUES(?, ?)"
  cars_data = [
      ('Chevrolet', 'Chevrolet Camaro'),
      ('Chevrolet', 'Chevrolet Captiva'),
      ('Fiat', 'Fiat 125 Mirafiori'),
      ('Fiat', 'Fiat 125 Centurion'),
      ('Honda', 'Honda CR-V'),
      ('Honda', 'Honda CR-X del Sol'),
      ('Honda', 'Honda CR-Z')
  ]

  result = db.run_query(insert_query, cars_data, True)
  print("Record inserted successfully into table", result.rowcount)
```

